{"ast":null,"code":"import apiClient from './client';\nclass DocumentService {\n  constructor() {\n    this.basePath = '/v1/documents';\n  }\n  // Get documents by folder\n  async getDocumentsByFolder(folderId) {\n    const response = await apiClient.get(`${this.basePath}/folder/${folderId}`);\n    return response.data;\n  }\n\n  // Get documents by company\n  async getDocumentsByCompany(companyId) {\n    const response = await apiClient.get(`${this.basePath}/company/${companyId}`);\n    return response.data;\n  }\n\n  // Get document by ID\n  async getDocumentById(id) {\n    const response = await apiClient.get(`${this.basePath}/${id}`);\n    return response.data;\n  }\n\n  // Create a new document\n  async createDocument(document) {\n    const response = await apiClient.post(this.basePath, document);\n    return response.data;\n  }\n\n  // Delete document\n  async deleteDocument(id) {\n    await apiClient.delete(`${this.basePath}/${id}`);\n  }\n\n  // Download document file\n  async downloadDocument(id) {\n    const response = await apiClient.get(`${this.basePath}/${id}/download`, {\n      responseType: 'blob'\n    });\n    return response.data;\n  }\n\n  // Helper method to create new document with defaults\n  createNewDocument(name, documentTypeId, companyId, folderId, departmentId) {\n    // Generate a unique code based on name and timestamp\n    const timestamp = Date.now();\n    const code = `${name.replace(/[^a-zA-Z0-9]/g, '').toUpperCase()}_${timestamp}`;\n    return {\n      name,\n      code,\n      documentTypeId,\n      companyId,\n      folderId,\n      departmentId,\n      fieldValues: {},\n      status: 'DRAFT'\n    };\n  }\n\n  // Helper method to prepare document for upload with file info\n  prepareDocumentForUpload(document, file) {\n    // Preserve existing physical location or create file metadata\n    let physicalLocation = document.physicalLocation;\n    if (!physicalLocation) {\n      physicalLocation = JSON.stringify({\n        fileName: file.name,\n        uploadTime: new Date().toISOString()\n      });\n    } else {\n      // If physical location exists, parse it and add file info\n      try {\n        const existing = JSON.parse(physicalLocation);\n        physicalLocation = JSON.stringify({\n          ...existing,\n          fileName: file.name,\n          uploadTime: new Date().toISOString()\n        });\n      } catch (e) {\n        // If parsing fails, create new object with file info\n        physicalLocation = JSON.stringify({\n          fileName: file.name,\n          uploadTime: new Date().toISOString()\n        });\n      }\n    }\n    return {\n      ...document,\n      filePath: `/uploads/${file.name}`,\n      fileSize: file.size,\n      mimeType: file.type,\n      physicalLocation\n    };\n  }\n}\nconst documentService = new DocumentService();\nexport default documentService;","map":{"version":3,"names":["apiClient","DocumentService","constructor","basePath","getDocumentsByFolder","folderId","response","get","data","getDocumentsByCompany","companyId","getDocumentById","id","createDocument","document","post","deleteDocument","delete","downloadDocument","responseType","createNewDocument","name","documentTypeId","departmentId","timestamp","Date","now","code","replace","toUpperCase","fieldValues","status","prepareDocumentForUpload","file","physicalLocation","JSON","stringify","fileName","uploadTime","toISOString","existing","parse","e","filePath","fileSize","size","mimeType","type","documentService"],"sources":["C:/Users/Administrator/Desktop/bika/bika/frontend/src/services/api/documentService.ts"],"sourcesContent":["import apiClient from './client';\r\nimport { Document, CreateDocumentRequest, ApiResponse } from './types';\r\n\r\nclass DocumentService {\r\n  private readonly basePath = '/v1/documents';\r\n\r\n  // Get documents by folder\r\n  async getDocumentsByFolder(folderId: number): Promise<Document[]> {\r\n    const response = await apiClient.get<Document[]>(`${this.basePath}/folder/${folderId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Get documents by company\r\n  async getDocumentsByCompany(companyId: number): Promise<Document[]> {\r\n    const response = await apiClient.get<Document[]>(`${this.basePath}/company/${companyId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Get document by ID\r\n  async getDocumentById(id: number): Promise<Document> {\r\n    const response = await apiClient.get<Document>(`${this.basePath}/${id}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Create a new document\r\n  async createDocument(document: CreateDocumentRequest): Promise<Document> {\r\n    const response = await apiClient.post<Document>(this.basePath, document);\r\n    return response.data;\r\n  }\r\n\r\n  // Delete document\r\n  async deleteDocument(id: number): Promise<void> {\r\n    await apiClient.delete(`${this.basePath}/${id}`);\r\n  }\r\n\r\n  // Download document file\r\n  async downloadDocument(id: number): Promise<Blob> {\r\n    const response = await apiClient.get(`${this.basePath}/${id}/download`, {\r\n      responseType: 'blob'\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Helper method to create new document with defaults\r\n  createNewDocument(\r\n    name: string, \r\n    documentTypeId: number, \r\n    companyId: number, \r\n    folderId?: number, \r\n    departmentId?: number\r\n  ): CreateDocumentRequest {\r\n    // Generate a unique code based on name and timestamp\r\n    const timestamp = Date.now();\r\n    const code = `${name.replace(/[^a-zA-Z0-9]/g, '').toUpperCase()}_${timestamp}`;\r\n    \r\n    return {\r\n      name,\r\n      code,\r\n      documentTypeId,\r\n      companyId,\r\n      folderId,\r\n      departmentId,\r\n      fieldValues: {},\r\n      status: 'DRAFT',\r\n    };\r\n  }\r\n\r\n  // Helper method to prepare document for upload with file info\r\n  prepareDocumentForUpload(\r\n    document: CreateDocumentRequest,\r\n    file: File\r\n  ): CreateDocumentRequest {\r\n    // Preserve existing physical location or create file metadata\r\n    let physicalLocation = document.physicalLocation;\r\n    if (!physicalLocation) {\r\n      physicalLocation = JSON.stringify({ fileName: file.name, uploadTime: new Date().toISOString() });\r\n    } else {\r\n      // If physical location exists, parse it and add file info\r\n      try {\r\n        const existing = JSON.parse(physicalLocation);\r\n        physicalLocation = JSON.stringify({ \r\n          ...existing, \r\n          fileName: file.name, \r\n          uploadTime: new Date().toISOString() \r\n        });\r\n      } catch (e) {\r\n        // If parsing fails, create new object with file info\r\n        physicalLocation = JSON.stringify({ fileName: file.name, uploadTime: new Date().toISOString() });\r\n      }\r\n    }\r\n    \r\n    return {\r\n      ...document,\r\n      filePath: `/uploads/${file.name}`,\r\n      fileSize: file.size,\r\n      mimeType: file.type,\r\n      physicalLocation,\r\n    };\r\n  }\r\n}\r\n\r\nconst documentService = new DocumentService();\r\nexport default documentService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}