{"ast":null,"code":"// Role-based access control utilities\n\n// Role hierarchy - higher number means higher privilege\nexport const ROLE_HIERARCHY = {\n  'USER': 1,\n  'MANAGER': 2,\n  'COMPANY_ADMIN': 3,\n  'SUPER_ADMIN': 4\n};\n\n// Check if user has a specific role\nexport const hasRole = (userRole, requiredRole) => {\n  if (!userRole) return false;\n  return userRole === requiredRole;\n};\n\n// Check if user has any of the required roles\nexport const hasAnyRole = (userRole, requiredRoles) => {\n  if (!userRole) return false;\n  return requiredRoles.includes(userRole);\n};\n\n// Check if user has minimum role level (equal or higher in hierarchy)\nexport const hasMinimumRole = (userRole, minimumRole) => {\n  if (!userRole) return false;\n  const userLevel = ROLE_HIERARCHY[userRole];\n  const minimumLevel = ROLE_HIERARCHY[minimumRole];\n  return userLevel >= minimumLevel;\n};\n\n// Get user-friendly role display name\nexport const getRoleDisplayName = role => {\n  if (!role) return 'User';\n  switch (role) {\n    case 'SUPER_ADMIN':\n      return 'Super Admin';\n    case 'COMPANY_ADMIN':\n      return 'Admin';\n    case 'MANAGER':\n      return 'Manager';\n    case 'USER':\n      return 'User';\n    default:\n      return role;\n  }\n};\n\n// Check if user can access a specific route based on role\nexport const canAccessRoute = (userRole, routePath) => {\n  if (!userRole) return false;\n\n  // Define route permissions\n  const routePermissions = {\n    '/dashboard': ['SUPER_ADMIN', 'COMPANY_ADMIN', 'MANAGER', 'USER'],\n    '/companies': ['SUPER_ADMIN'],\n    '/users': ['SUPER_ADMIN', 'COMPANY_ADMIN'],\n    '/document-types': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\n    '/archival': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\n    '/retrieval': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\n    '/reports': ['MANAGER'],\n    '/drive': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\n    '/settings': ['SUPER_ADMIN', 'COMPANY_ADMIN', 'MANAGER', 'USER']\n  };\n  const allowedRoles = routePermissions[routePath];\n  return allowedRoles ? hasAnyRole(userRole, allowedRoles) : false;\n};\n\n// Get menu items for a specific role\n\nexport const getMenuItemsForRole = (userRole, allMenuItems) => {\n  if (!userRole) return [];\n  return allMenuItems.filter(item => item.roles.includes(userRole));\n};","map":{"version":3,"names":["ROLE_HIERARCHY","hasRole","userRole","requiredRole","hasAnyRole","requiredRoles","includes","hasMinimumRole","minimumRole","userLevel","minimumLevel","getRoleDisplayName","role","canAccessRoute","routePath","routePermissions","allowedRoles","getMenuItemsForRole","allMenuItems","filter","item","roles"],"sources":["C:/Users/Administrator/Desktop/bika/bika/frontend/src/utils/roleUtils.ts"],"sourcesContent":["// Role-based access control utilities\r\n\r\nexport type UserRole = 'SUPER_ADMIN' | 'COMPANY_ADMIN' | 'MANAGER' | 'USER';\r\n\r\n// Role hierarchy - higher number means higher privilege\r\nexport const ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  'USER': 1,\r\n  'MANAGER': 2,\r\n  'COMPANY_ADMIN': 3,\r\n  'SUPER_ADMIN': 4,\r\n};\r\n\r\n// Check if user has a specific role\r\nexport const hasRole = (userRole: string | undefined, requiredRole: UserRole): boolean => {\r\n  if (!userRole) return false;\r\n  return userRole === requiredRole;\r\n};\r\n\r\n// Check if user has any of the required roles\r\nexport const hasAnyRole = (userRole: string | undefined, requiredRoles: UserRole[]): boolean => {\r\n  if (!userRole) return false;\r\n  return requiredRoles.includes(userRole as UserRole);\r\n};\r\n\r\n// Check if user has minimum role level (equal or higher in hierarchy)\r\nexport const hasMinimumRole = (userRole: string | undefined, minimumRole: UserRole): boolean => {\r\n  if (!userRole) return false;\r\n  const userLevel = ROLE_HIERARCHY[userRole as UserRole];\r\n  const minimumLevel = ROLE_HIERARCHY[minimumRole];\r\n  return userLevel >= minimumLevel;\r\n};\r\n\r\n// Get user-friendly role display name\r\nexport const getRoleDisplayName = (role: string | undefined): string => {\r\n  if (!role) return 'User';\r\n  \r\n  switch (role) {\r\n    case 'SUPER_ADMIN':\r\n      return 'Super Admin';\r\n    case 'COMPANY_ADMIN':\r\n      return 'Admin';\r\n    case 'MANAGER':\r\n      return 'Manager';\r\n    case 'USER':\r\n      return 'User';\r\n    default:\r\n      return role;\r\n  }\r\n};\r\n\r\n// Check if user can access a specific route based on role\r\nexport const canAccessRoute = (userRole: string | undefined, routePath: string): boolean => {\r\n  if (!userRole) return false;\r\n\r\n  // Define route permissions\r\n  const routePermissions: Record<string, UserRole[]> = {\r\n    '/dashboard': ['SUPER_ADMIN', 'COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n    '/companies': ['SUPER_ADMIN'],\r\n    '/users': ['SUPER_ADMIN', 'COMPANY_ADMIN'],\r\n    '/document-types': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n    '/archival': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n    '/retrieval': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n    '/reports': ['MANAGER'],\r\n    '/drive': ['COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n    '/settings': ['SUPER_ADMIN', 'COMPANY_ADMIN', 'MANAGER', 'USER'],\r\n  };\r\n\r\n  const allowedRoles = routePermissions[routePath];\r\n  return allowedRoles ? hasAnyRole(userRole, allowedRoles) : false;\r\n};\r\n\r\n// Get menu items for a specific role\r\nexport interface MenuItem {\r\n  text: string;\r\n  icon: React.ReactNode;\r\n  path: string;\r\n  roles: UserRole[];\r\n}\r\n\r\nexport const getMenuItemsForRole = (userRole: string | undefined, allMenuItems: MenuItem[]): MenuItem[] => {\r\n  if (!userRole) return [];\r\n  \r\n  return allMenuItems.filter(item => item.roles.includes(userRole as UserRole));\r\n}; "],"mappings":"AAAA;;AAIA;AACA,OAAO,MAAMA,cAAwC,GAAG;EACtD,MAAM,EAAE,CAAC;EACT,SAAS,EAAE,CAAC;EACZ,eAAe,EAAE,CAAC;EAClB,aAAa,EAAE;AACjB,CAAC;;AAED;AACA,OAAO,MAAMC,OAAO,GAAGA,CAACC,QAA4B,EAAEC,YAAsB,KAAc;EACxF,IAAI,CAACD,QAAQ,EAAE,OAAO,KAAK;EAC3B,OAAOA,QAAQ,KAAKC,YAAY;AAClC,CAAC;;AAED;AACA,OAAO,MAAMC,UAAU,GAAGA,CAACF,QAA4B,EAAEG,aAAyB,KAAc;EAC9F,IAAI,CAACH,QAAQ,EAAE,OAAO,KAAK;EAC3B,OAAOG,aAAa,CAACC,QAAQ,CAACJ,QAAoB,CAAC;AACrD,CAAC;;AAED;AACA,OAAO,MAAMK,cAAc,GAAGA,CAACL,QAA4B,EAAEM,WAAqB,KAAc;EAC9F,IAAI,CAACN,QAAQ,EAAE,OAAO,KAAK;EAC3B,MAAMO,SAAS,GAAGT,cAAc,CAACE,QAAQ,CAAa;EACtD,MAAMQ,YAAY,GAAGV,cAAc,CAACQ,WAAW,CAAC;EAChD,OAAOC,SAAS,IAAIC,YAAY;AAClC,CAAC;;AAED;AACA,OAAO,MAAMC,kBAAkB,GAAIC,IAAwB,IAAa;EACtE,IAAI,CAACA,IAAI,EAAE,OAAO,MAAM;EAExB,QAAQA,IAAI;IACV,KAAK,aAAa;MAChB,OAAO,aAAa;IACtB,KAAK,eAAe;MAClB,OAAO,OAAO;IAChB,KAAK,SAAS;MACZ,OAAO,SAAS;IAClB,KAAK,MAAM;MACT,OAAO,MAAM;IACf;MACE,OAAOA,IAAI;EACf;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAGA,CAACX,QAA4B,EAAEY,SAAiB,KAAc;EAC1F,IAAI,CAACZ,QAAQ,EAAE,OAAO,KAAK;;EAE3B;EACA,MAAMa,gBAA4C,GAAG;IACnD,YAAY,EAAE,CAAC,aAAa,EAAE,eAAe,EAAE,SAAS,EAAE,MAAM,CAAC;IACjE,YAAY,EAAE,CAAC,aAAa,CAAC;IAC7B,QAAQ,EAAE,CAAC,aAAa,EAAE,eAAe,CAAC;IAC1C,iBAAiB,EAAE,CAAC,eAAe,EAAE,SAAS,EAAE,MAAM,CAAC;IACvD,WAAW,EAAE,CAAC,eAAe,EAAE,SAAS,EAAE,MAAM,CAAC;IACjD,YAAY,EAAE,CAAC,eAAe,EAAE,SAAS,EAAE,MAAM,CAAC;IAClD,UAAU,EAAE,CAAC,SAAS,CAAC;IACvB,QAAQ,EAAE,CAAC,eAAe,EAAE,SAAS,EAAE,MAAM,CAAC;IAC9C,WAAW,EAAE,CAAC,aAAa,EAAE,eAAe,EAAE,SAAS,EAAE,MAAM;EACjE,CAAC;EAED,MAAMC,YAAY,GAAGD,gBAAgB,CAACD,SAAS,CAAC;EAChD,OAAOE,YAAY,GAAGZ,UAAU,CAACF,QAAQ,EAAEc,YAAY,CAAC,GAAG,KAAK;AAClE,CAAC;;AAED;;AAQA,OAAO,MAAMC,mBAAmB,GAAGA,CAACf,QAA4B,EAAEgB,YAAwB,KAAiB;EACzG,IAAI,CAAChB,QAAQ,EAAE,OAAO,EAAE;EAExB,OAAOgB,YAAY,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,KAAK,CAACf,QAAQ,CAACJ,QAAoB,CAAC,CAAC;AAC/E,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}