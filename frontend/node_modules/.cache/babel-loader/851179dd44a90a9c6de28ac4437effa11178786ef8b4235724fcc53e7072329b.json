{"ast":null,"code":"import _objectSpread from\"C:/Users/Yann/Desktop/biakasystem/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useReducer,useEffect}from\"react\";import{AuthService}from\"../services/api/authService\";// Auth State Interface\n// Auth Actions\n// Auth Context Interface\nimport{jsx as _jsx}from\"react/jsx-runtime\";// Initial state\nconst initialState={user:null,isAuthenticated:false,isLoading:true,error:null};// Auth reducer\nconst authReducer=(state,action)=>{switch(action.type){case\"AUTH_START\":return _objectSpread(_objectSpread({},state),{},{isLoading:true,error:null});case\"AUTH_SUCCESS\":return _objectSpread(_objectSpread({},state),{},{user:action.payload,isAuthenticated:true,isLoading:false,error:null});case\"AUTH_FAILURE\":return _objectSpread(_objectSpread({},state),{},{user:null,isAuthenticated:false,isLoading:false,error:action.payload});case\"AUTH_LOGOUT\":return _objectSpread(_objectSpread({},state),{},{user:null,isAuthenticated:false,isLoading:false,error:null});case\"AUTH_CLEAR_ERROR\":return _objectSpread(_objectSpread({},state),{},{error:null});case\"AUTH_UPDATE_USER\":return _objectSpread(_objectSpread({},state),{},{user:action.payload});default:return state;}};// Create context\nconst AuthContext=/*#__PURE__*/createContext(undefined);// Auth Provider Props\n// Auth Provider Component\nexport const AuthProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(authReducer,initialState);// Initialize auth state on mount\nuseEffect(()=>{const initializeAuth=async()=>{try{dispatch({type:\"AUTH_START\"});// Check if user is authenticated\nif(AuthService.isAuthenticated()){const storedUser=AuthService.getStoredUser();if(storedUser){dispatch({type:\"AUTH_SUCCESS\",payload:storedUser});// Optionally refresh user data from server\ntry{const currentUser=await AuthService.getCurrentUser();dispatch({type:\"AUTH_UPDATE_USER\",payload:currentUser});}catch(error){// If refresh fails, keep stored user but log error\nconsole.warn(\"Failed to refresh user data:\",error);}}else{dispatch({type:\"AUTH_LOGOUT\"});}}else{dispatch({type:\"AUTH_LOGOUT\"});}}catch(error){console.error(\"Auth initialization failed:\",error);dispatch({type:\"AUTH_LOGOUT\"});}};initializeAuth();},[]);// Login function\nconst login=async credentials=>{try{dispatch({type:\"AUTH_START\"});const response=await AuthService.login(credentials);dispatch({type:\"AUTH_SUCCESS\",payload:response.user});}catch(error){const errorMessage=(error===null||error===void 0?void 0:error.message)||\"Login failed. Please try again.\";dispatch({type:\"AUTH_FAILURE\",payload:errorMessage});throw error;}};// Register function\nconst register=async userData=>{try{dispatch({type:\"AUTH_START\"});const response=await AuthService.register(userData);dispatch({type:\"AUTH_SUCCESS\",payload:response.user});}catch(error){const errorMessage=(error===null||error===void 0?void 0:error.message)||\"Registration failed. Please try again.\";dispatch({type:\"AUTH_FAILURE\",payload:errorMessage});throw error;}};// Logout function\nconst logout=async()=>{try{await AuthService.logout();}catch(error){console.error(\"Logout error:\",error);}finally{dispatch({type:\"AUTH_LOGOUT\"});}};// Clear error function\nconst clearError=()=>{dispatch({type:\"AUTH_CLEAR_ERROR\"});};// Refresh user data\nconst refreshUser=async()=>{try{if(state.isAuthenticated){const user=await AuthService.getCurrentUser();dispatch({type:\"AUTH_UPDATE_USER\",payload:user});}}catch(error){console.error(\"Failed to refresh user:\",error);// Don't dispatch error for refresh failures\n}};// Update user data\nconst updateUser=user=>{AuthService.updateStoredUser(user);dispatch({type:\"AUTH_UPDATE_USER\",payload:user});};// Context value\nconst contextValue={state,login,register,logout,clearError,refreshUser,updateUser};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:contextValue,children:children});};// Custom hook to use auth context\nexport const useAuth=()=>{const context=useContext(AuthContext);if(context===undefined){throw new Error(\"useAuth must be used within an AuthProvider\");}return context;};// Hook to get current user\nexport const useCurrentUser=()=>{const{state}=useAuth();return state.user;};// Hook to check authentication status\nexport const useIsAuthenticated=()=>{const{state}=useAuth();return state.isAuthenticated;};// Hook to check if user has specific role\nexport const useHasRole=role=>{const user=useCurrentUser();return(user===null||user===void 0?void 0:user.role)===role||false;};// Hook to check if user is admin\nexport const useIsAdmin=()=>{const user=useCurrentUser();return(user===null||user===void 0?void 0:user.role)===\"SUPER_ADMIN\"||(user===null||user===void 0?void 0:user.role)===\"COMPANY_ADMIN\"||false;};// Hook to get user's company ID\nexport const useUserCompanyId=()=>{const user=useCurrentUser();return(user===null||user===void 0?void 0:user.companyId)||null;};// Hook to get user's department ID\nexport const useUserDepartmentId=()=>{const user=useCurrentUser();return(user===null||user===void 0?void 0:user.departmentId)||null;};export default AuthContext;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}